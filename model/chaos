    for (int step = 0; step < steps; ++step) 
    {
        bool isOffScreen = true;
        double x = t;
        double y = t;

        for (int iter = 0; iter < iters; ++iter) 
        {
            double const xx = x * x;
            double const yy = y * y;
            double const tt = t * t;
            double const xy = x * y;
            double const xt = x * t;
            double const yt = y * t;
            double const nx = xx*params[0] + yy*params[1] 
                + tt*params[2] + xy*params[3] + xt*params[4] 
                + yt*params[5] + x*params[6] + y*params[7] 
                + t*params[8];
            double const ny = xx*params[9] + yy*params[10] 
                + tt*params[11] + xy*params[12] + xt*params[13] 
                + yt*params[14] + x*params[15] + y*params[16] 
                + t*params[17];
            x = nx;
            y = ny;
            sf::Vector2f screenPt = ToScreen(x, y);
            if (iteration_limit && iter < 100) 
            {
                screenPt.x = FLT_MAX;
                screenPt.y = FLT_MAX;
            }
            vertex_array[step*iters + iter].position = screenPt;

            //Check if dynamic delta should be adjusted
            if (screenPt.x > 0.0f && screenPt.y > 0.0f && 
                    screenPt.x < window_w && screenPt.y < window_h) 
            {
                float const dx = history[iter].x - float(x);
                float const dy = history[iter].y - float(y);
                double const dist = 
                    double(500.0f * std::sqrt(dx*dx + dy*dy));
                rolling_delta = std::min(rolling_delta, 
                        std::max(delta / (dist + 1e-5), 
                            delta_minimum*speed_mult));
                isOffScreen = false;
            }
            history[iter].x = float(x);
            history[iter].y = float(y);
        }

        //Update the t variable
        if (isOffScreen) 
            t += 0.01;
        else
            t += rolling_delta;
    }

